package main

import "fmt"

/*
尾调用：一个函数的最后一个动作是调用函数
如果最后一个动作是调用自身，称为尾递归，是尾调用的特殊情况

一些编译器能对尾调用进行优化，以达到节省栈空间的目的

为什么尾调用能优化？不是尾调用就不能优化吗？
尾调用优化也叫尾调用消除
如果当前栈帧上的局部变量等内容都不要用了，当前栈帧经过适当的改变后可以直接当做被尾调用的函数的栈帧使用，然后程序可以jump到被尾调用的函数代码
生成栈帧改变代码与jump的过程称作尾调用消除或叫尾调用优化
尾调用优化让位于尾位置的函数跟调用跟goto语句性能一样高

消除尾递归里面的尾调用比消除一般的尾调用容易的多：
比如java虚拟机里的jvm是会消除尾递归里的尾调用，但不会消除一般的尾调用（因为改变不了栈帧）
因此尾递归优化相对比较普遍，平时的递归代码可以尽量考虑使用尾递归的形式
*/

func main() {
	//test1()
}
func test1() {
	a := 10
	b := a + 20
	test2(b)
}
func test2(n int) {
	fmt.Println(n)
}












